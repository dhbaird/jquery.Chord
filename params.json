{"name":"Chord","tagline":"jQuery Chord is a plug-in library for jQuery 1.3+ that may be used to detect and act upon key sequences entered by a user.","body":"#About\r\n\r\njQuery.Chord is a plug-in library for jQuery 1.3+ that lets you detect and act upon user keyboard input. This is accomplished by wiring Chord up to listen for key sequences, known as chords, entered by a user.\r\n\r\nChord was inspired by John Resig's [jQuery.hotkeys](https://github.com/jeresig/jquery.hotkeys). Though we are big fans of jQuery.hotkeys (and John) the plugin lacks functionality we have included in Chord.\r\n\r\n#Usage\r\n\r\nChord may be attached to any DOM node in order to listen for sequences of keyboard activity within that node and its descendants. In its simplest form Chord can be enabled like this:\r\n\r\n    $(expression).chord('bindLiteralSequence', 'hello', function () { console.log('world') });\r\n\r\n##Examples\r\n\r\nWhile the above is great for simple keyboard input it is Chord's more advance uses where it begins to sing. Chord offers a variety of configuration options and makes it easy to handle a number of key sequences with a single configuration. A more advanced form of the above would look likes this:\r\n\r\n    $(expression).chord({\r\n        sequenceMap: [{\r\n            sequence: $.chord.literalStringToSequence('hello'),\r\n            matched: function () {\r\n                console.log('world')\r\n            }\r\n        }]\r\n    });\r\n\r\nWhich admittedly looks unnecessarily more complicated until you realize it allows you to do things like this:\r\n\r\n    $(expression).chord('bind', [{\r\n        sequence: $.chord.literalStringToSequence('mouse'),\r\n        matched: function () {\r\n            console.log('squeak!')\r\n        }\r\n    }, {\r\n        sequence: [\r\n        $.chord.literalStringToSequence('cow'),\r\n        $.chord.literalStringToSequence('bull'), ],\r\n        matched: function () {\r\n            console.log('moo!')\r\n        }\r\n    }]);\r\n\r\nTODO we need to put additional examples here.\r\n\r\n##Options\r\nIn the above examples we are making use of Chord's `options` object which may contain the following, otherwise defaults are used:\r\n\r\n- **captureShift** `(bool)` default: `[false]`\r\nTreat shift as a key press. \r\n\r\n- **captureAlt** `(bool)` default: `[false]`\r\nTreat alt as a key press.\r\n\r\n- **captureCtrl** `(bool)` default: `[false]`\r\nTreat ctrl as a key press.        \r\n\r\n- **ignoreFormElements** `(bool)` default: `[true]`\r\nIgnore key presses within form elements\r\n\r\n- **keyEvent** `(string)` default: `[keyup]`\r\nthe key event that triggers listening. other options are keydown (or any event that stores the key code *not ASCII char code* within the 'which' property of the event)\r\n\r\n- **maxBufferLength** `(int)` default: `[5]`\r\nthe length of the key buffer. Note that the buffer will be auto expanded in order to maintain at minimum the length of the longest sequence to be detected. Modifying this allows for a greater depth of key press history to be kept if desired\r\n\r\n- **clearBufferOnMatch** `(bool)` default: `[true]`\r\ndetermines if the key buffer should be cleared on a match\r\n\r\n- **paused** `(bool)` default: `[false]`\r\ndetermines if chord on the element should start paused (not collecting key)\r\n\r\n- **sequenceMap** `(object array)` default: `[empty array]`\r\nan array of objects defining sequence mapping. Defaults to an empty array. Mapping object may have the following attributes\r\n\r\n - **sequence** - a sequence, array of sequences, or array of sequence parts\r\nto create a sequence from a string use\r\n`$.chord.literalStringToSequence(str)`\r\nor to create a part use\r\n`$.chord.makeSequencePart(keyCode, shift, alt, ctrl)`\r\n\r\n - **matched** - optional function that will be called on sequence completion\r\n\r\n - **lookup** - optional lookup code that will be passed to the custom `chordMatch` event on sequence completion\r\n\r\n##Methods\r\n\r\n- **clearSequenceBuffer**\r\nclear the sequence buffer, effectively resetting the memory of previously pressed keys\r\n`$(expression).chord('clearSequenceBuffer')`\r\n\r\n- **destroy**\r\ndestroy the chord instance unbinding events and removing data from element\r\n`$(expression).chord('destroy')`\r\n\r\n- **pause**\r\npause the chord instance\r\n`$(expression).chord('pause')`\r\n\r\n- **resume**\r\nresume the chord instance\r\n`$(expression).chord('resume')`\r\n\r\n- **togglePause**\r\npause/resume chord instance if was unpaused/paused\r\n`$(expression).chord('togglePause')`\r\n\r\n- **bind(args)**\r\nbind new sequence(s)\r\nargs[0] array of sequence/lookup/matched objects to add to the sequenceMap\r\n\r\n        $(expression).chord('bind', {\r\n            sequence: $.chord.literalStringToSequence('mouse'),\r\n            matched: function () {\r\n                console.log('squeak!')\r\n            }\r\n        });\r\n\r\n- **unbind(args)**\r\nunbind each occurrence of a sequence\r\nargs[0] the sequence to unbind\r\n`$(expression).chord('unbind', $.chord.literalStringToSequence('mouse'));`\r\n\r\n- **actOnBuffer**\r\nact on data in buffer as if a listen event has occurred\r\n`$(expression).chord('actOnBuffer')`\r\n\r\n- **pushSequence(args)**\r\npush a sequence onto the buffer. Not that this will not cause a listen to be fired. You must call actOnBuffer if a reaction is desired. To push and act on buffer call pushSequenceAndAct\r\nargs[0] sequence to push (array of sequence parts)\r\n`$(expression).chord('pushSequence', $.chord.literalStringToSequence('dog'))`\r\n\r\n- **pushSequenceAndActOnBuffer(args)**\r\npush a sequence onto the buffer and act upon it\r\nargs[0] sequence to push (array of sequence parts)\r\n`$(expression).chord('pushSequenceAndAct', $.chord.literalStringToSequence('dog'))`\r\n\r\n##Events\r\nChord also makes available a custom 'chordMatch' event. This event object will contain the following NEW properties:\r\n\r\n- **originalEvent** - the original triggering event event\r\n- **lookup** - the lookup as defined in the sequence map\r\n- **sequence** - the sequence that triggered the event\r\n- **sequenceString** - the triggering sequence as a string\r\n\r\nBelow is an example of a handler of the chordMatch event.\r\n\r\n    $(expression).on('chordMatch', function (e) {\r\n        console.log('chordMatch event:');\r\n        console.log('\\t event:', e);\r\n        console.log('\\t lookup:', e.lookup);\r\n        console.log('\\t sequence:', e.sequence);\r\n        console.log('\\t sequenceString:', e.sequenceString);\r\n        console.log('\\t originalEvent:', e.originalEvent);\r\n    });","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}